\chapter{Análisis Práctico}\label{ch:practical_analytics}

\section{Requisitos funcionales y no funcionales}

La definición de los requisitos del sistema resultó ser un proceso más complejo de lo anticipado inicialmente. Se había considerado que consistiría simplemente en elaborar una lista de las funcionalidades deseadas para el sistema; sin embargo, se constató que muchos requisitos no se manifiestan hasta que se inicia la implementación y surgen problemas no previstos. Configurando así un proceso marcadamente iterativo, donde cada fase del desarrollo revelaba nuevas necesidades.

\subsection{Requisitos Funcionales}

Los requisitos funcionales definen esencialmente las operaciones que el sistema debe realizar. A continuación, se presentan aquellos identificados a partir del análisis del código final:

\begin{itemize}
    \item \textbf{RF-01}: El sistema debe permitir la conexión y desconexión con el dispositivo EEG (electroencefalograma).
    \item \textbf{RF-02}: El sistema debe capturar los datos crudos (raw) de los canales T3, T4, O1 y O2 del dispositivo EEG.
    \item \textbf{RF-03}: El sistema debe obtener datos de impedancia del dispositivo EEG para verificar la calidad de la señal.
    \item \textbf{RF-04}: El sistema debe permitir el cambio entre distintos modos de trabajo del dispositivo EEG.
    \item \textbf{RF-05}: El sistema debe implementar un modelo de inferencia para predecir el color en el que está pensando el usuario.
    \item \textbf{RF-06}: El sistema debe distinguir entre al menos dos colores (rojo y verde) y un estado 'desconocido'.
    \item \textbf{RF-07}: El sistema debe controlar la activación y desactivación de una bombilla inteligente.
    \item \textbf{RF-08}: El sistema debe proporcionar una interfaz gráfica que permita visualizar el estado de la conexión del dispositivo EEG.
    \item \textbf{RF-09}: El sistema debe permitir visualizar la señal EEG en tiempo real.
    \item \textbf{RF-10}: El sistema debe mostrar al usuario las predicciones realizadas por el modelo de inferencia.
\end{itemize}

\newpage

\subsection{Requisitos No Funcionales}

La definición de los requisitos no funcionales representó el aspecto más intrincado. En esta categoría se incluyen temas como el rendimiento, la seguridad y el cumplimiento de normativas —aspectos que con frecuencia se omiten en las fases iniciales por ser menos evidentes—. Algunos de estos requisitos no habían sido siquiera considerados hasta el inicio de las primeras pruebas del sistema, momento en el cual se observó que ciertos componentes no operaban según lo esperado. Los requisitos finalmente identificados son:

\begin{itemize}
    \item \textbf{RNF-01}: \textbf{Normativa}: El sistema debe cumplir con la norma UNE-EN 62304:2007 para software de dispositivos médicos.\label{rnf-01}
    \item \textbf{RNF-02}: \textbf{Tiempo Real}: El sistema debe operar en tiempo real blando para asegurar una respuesta adecuada a los cambios en la señal EEG.\label{rnf-02}
    \item \textbf{RNF-03}: \textbf{Fiabilidad}: El sistema debe validar la calidad de las señales EEG mediante los datos de impedancia antes de realizar predicciones.\label{rnf-03}
    \item \textbf{RNF-04}: \textbf{Portabilidad}: El sistema debe poder ejecutarse en una Raspberry Pi.\label{rnf-04}
    \item \textbf{RNF-05}: \textbf{Seguridad}: El sistema debe garantizar la privacidad y seguridad de los datos biométricos del usuario.\label{rnf-05}
    \item \textbf{RNF-06}: \textbf{Interoperabilidad}: El sistema debe integrarse con dispositivos domóticos estándar (bombillas inteligentes).\label{rnf-06}
    \item \textbf{RNF-07}: \textbf{Mantenibilidad}: El sistema debe seguir un diseño hexagonal (puertos y adaptadores) para facilitar su mantenimiento y pruebas.\label{rnf-07}
    \item \textbf{RNF-08}: \textbf{Usabilidad}: La interfaz gráfica debe ser intuitiva y proporcionar retroalimentación clara sobre el estado del sistema.\label{rnf-08}
    \item \textbf{RNF-09}: \textbf{Escalabilidad}: La arquitectura debe permitir la inclusión de nuevos tipos de predicciones o dispositivos de salida.\label{rnf-09}
    \item \textbf{RNF-10}: \textbf{Rendimiento}: El sistema debe ser capaz de procesar y analizar señales EEG con una latencia mínima.\label{rnf-10}
\end{itemize}

\newpage

\section{Bibliotecas Usadas}

La selección de las bibliotecas adecuadas requirió un tiempo considerable de investigación. Inicialmente, se pensó que sería suficiente con identificar las opciones más populares; sin embargo, se constató que muchas tecnologías que parecían idóneas en teoría, posteriormente no operaban correctamente con los requisitos de tiempo real o no compilaban para la arquitectura ARM. Este fue un caso donde la teoría y la práctica presentaron divergencias significativas.

El proyecto utiliza una combinación de bibliotecas para diferentes propósitos. Algunas fueron seleccionadas desde el inicio, mientras que otras se incorporaron a medida que surgían necesidades específicas no previstas. A continuación, se organizan según su función principal:

\subsection{Procesamiento de Señales EEG}
\begin{itemize}
    \item \textbf{BrainFlow}: Biblioteca para la adquisición y procesamiento de datos de dispositivos de electroencefalografía (EEG). Permite la comunicación con el dispositivo BrainBit y la captura de datos en tiempo real.
\end{itemize}

\subsection{Interfaz Gráfica y Visualización}
\begin{itemize}
    \item \textbf{slint}: Framework para la creación de interfaces gráficas, con soporte para Rust y con características de alta eficiencia.
    \item \textbf{plotters}: Biblioteca para la creación de gráficos y visualizaciones en Rust, utilizada para mostrar las señales EEG en tiempo real.
\end{itemize}

\subsection{Inteligencia Artificial y Procesamiento de Datos}
\begin{itemize}
    \item \textbf{PyTorch}: Framework de aprendizaje profundo utilizado para el entrenamiento del modelo de clasificación de señales EEG.
    \item \textbf{ONNX}: Formato estándar para la representación de modelos de aprendizaje automático que permite la interoperabilidad entre diferentes frameworks.
    \item \textbf{tract-onnx}: Biblioteca en Rust para la ejecución de modelos ONNX, utilizada para las inferencias en tiempo real.
    \item \textbf{ndarray}: Biblioteca para el procesamiento de arrays multidimensionales en Rust, utilizada para el preprocesamiento de datos.
\end{itemize}

\subsection{Comunicación y Control de Dispositivos}
\begin{itemize}
    \item \textbf{tapo}: Cliente en Rust para controlar dispositivos inteligentes Tapo, utilizado para la bombilla inteligente que responde a las señales cerebrales del usuario.
    \item \textbf{presage}: Biblioteca de gestión de eventos y mensajería para la comunicación entre componentes.
\end{itemize}

\subsection{Herramientas de Concurrencia y Asincronía}
\begin{itemize}
    \item \textbf{tokio}: Runtime asíncrono para Rust que facilita la programación concurrente, esencial para manejar múltiples flujos de datos en tiempo real.
    \item \textbf{async-trait}: Permite la definición de traits asíncronos en Rust.
\end{itemize}

\subsection{Arquitectura y Diseño del Sistema}
\begin{itemize}
    \item \textbf{statig}: Biblioteca para la implementación del patrón máquina de estados en Rust, utilizada para gestionar el ciclo de vida de la aplicación.
    \item \textbf{once\_cell}: Para la implementación de singletons en Rust, utilizado en la gestión de recursos compartidos.
\end{itemize}

\subsection{Serialización y Estructuras de Datos}
\begin{itemize}
    \item \textbf{serde}: Framework de serialización/deserialización para Rust, utilizado para el intercambio de datos entre componentes.
    \item \textbf{chrono}: Biblioteca para el manejo de fechas y tiempos en Rust.
\end{itemize}
