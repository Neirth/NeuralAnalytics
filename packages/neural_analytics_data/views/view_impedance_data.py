# Copyright (C) 2025 Sergio Mart√≠nez Aznar
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
Visualization of impedance data for the EEG capture system.
This module handles the initial configuration screen where impedance
values are displayed to ensure good contact of the electrodes.
"""

import time
import io
import sys
from collections import deque

from config.settings import (
    APP_STATE_SETUP, APP_STATE_ERROR,
    CHANNEL_MAP, MAX_HISTORY
)

from hardware.brainbit import get_resistance_values
from utils.helpers import get_impedance_status, play_sound
from views.view_layout import view_header, view_electrode_graph, view_status_bar

def view_impedance_screen(term, board, history, control_event=None, data_provider=None):
    """
    Displays the configuration screen with electrode impedance data.
    
    Args:
        term: Blessed terminal
        board: BoardShim object of the BrainBit device
        history: Dictionary to store value history
        control_event: Event to control loop interruption
        data_provider: Function that provides current data (eeg_values, imp_values)
        
    Returns:
        dict: Event generated by the view or False in case of error
    """
    electrodes = ["T3", "T4", "O1", "O2"]
    
    # Initialize impedance histories if necessary
    for electrode in electrodes:
        if f"{electrode}_imp" not in history:
            history[f"{electrode}_imp"] = deque(maxlen=MAX_HISTORY)
    
    # Counter for periodic updates
    if 'update_count' not in history:
        history['update_count'] = 0
    update_count = history['update_count']
    update_count += 1
    history['update_count'] = update_count
    
    try:
        if control_event and control_event.is_set():
            return {'event': 'cancel'}
            
        # Get current terminal dimensions
        width = term.width
        height = term.height
        
        # Calculate graph dimensions based on current size
        graph_width = width // 2 - 4
        graph_height = (height - 14) // 2  # Reduced from 10 to 14 for more space
        
        # Calculate margin for better centering
        margin_x = (width - graph_width * 2) // 3
        
        # Graph positions (2x2 grid)
        positions = {
            "T3": (margin_x, 5),
            "T4": (margin_x * 2 + graph_width, 5),
            "O1": (margin_x, 5 + graph_height + 1),  # Reduced from +2 to +1
            "O2": (margin_x * 2 + graph_width, 5 + graph_height + 1)  # Reduced from +2 to +1
        }
        
        # Temporarily redirect stdout to capture output
        old_stdout = sys.stdout
        buffer = io.StringIO()
        sys.stdout = buffer
        
        # Draw all elements in the buffer
        print(term.home + term.clear_eos, end='')
        view_header(term, y_start=1)
        
        # Get impedance values
        if data_provider:
            _, resistance_values = data_provider()
        else:
            resistance_values = get_resistance_values(board, electrodes)
            
        # Check impedance status
        all_ok = all(get_impedance_status(resistance_values[e])[1] <= 2 for e in electrodes)
        
        # Message based on status
        if all_ok:
            status_msg = "All electrodes have good contact! Press ENTER to continue"
        else:
            status_msg = "Adjust the electrodes until all have EXCELLENT or ACCEPTABLE contact"
        
        # Draw impedance graphs
        for electrode in electrodes:
            value = resistance_values[electrode]
            x, y = positions[electrode]
            
            level = view_electrode_graph(
                term, x, y, graph_width, graph_height,
                electrode, value, history, APP_STATE_SETUP
            )
            
            # Update history for this electrode
            if f"{electrode}_imp" in history:
                history[f"{electrode}_imp"].append(value)
        
        # Status bar
        view_status_bar(term, height - 7, APP_STATE_SETUP, status_msg)
        
        # Restore stdout and send all the buffer at once
        sys.stdout = old_stdout
        print(buffer.getvalue(), end='', flush=True)
        
        # Check user input
        key = term.inkey(timeout=0.1, esc_delay=0)

        if key:
            # Print information about the key
            debug_msg = f"Key: {repr(key)}, code: {key.code if hasattr(key, 'code') else 'N/A'}"
            print(term.move_xy(2, height - 2) + term.clear_eol + debug_msg, end='', flush=True)
            
            # ENTER: Continue only if impedance is correct
            is_enter = (key.code == term.KEY_ENTER or key == '\n' or key == '\r')
            if is_enter and all_ok:
                print(term.move_xy(2, height - 3) + term.clear_eol + "ENTER detected! Moving forward...", end='', flush=True)
                play_sound("Correct impedance, continue")
                return {'event': 'key_press', 'key': 'enter', 'impedance_ok': True}
            
            # ESC or Q: Cancel
            elif key.code == term.KEY_ESCAPE or key == 'q' or key == 'Q':
                play_sound("Operation canceled")
                return {'event': 'key_press', 'key': 'escape'}
        
    except Exception as e:
        print(term.move_xy(1, 1) + term.clear + term.bold_red(f"Error: {str(e)}"))
        time.sleep(3)
        return False
        
    return None