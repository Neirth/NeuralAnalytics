# Copyright (C) 2025 Sergio Mart√≠nez Aznar
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
Visualization of data during EEG capture.
This module handles the presentation of EEG data during the
countdown, capture, and completion phases.
"""

import time
from collections import deque

from config.settings import (
    APP_STATE_COUNTDOWN, APP_STATE_CAPTURE, APP_STATE_COMPLETE, APP_STATE_ERROR,
    CHANNEL_MAP, MAX_HISTORY, INITIAL_DELAY, NUM_SAMPLES
)

from utils.helpers import play_sound
from views.view_layout import view_header, view_electrode_graph, view_status_bar

def view_capture_screen(term, data_provider, history, state_info, control_event=None):
    """
    Displays the EEG data capture screen.
    
    Args:
        term: Blessed terminal
        data_provider: Function that provides current data
        history: Dictionary to store value history
        state_info: Dictionary with current state information
        control_event: Event to control loop interruption
    
    Returns:
        dict: Event generated by the view
    """
    electrodes = ["T3", "T4", "O1", "O2"]
    
    # Initialize EEG histories if necessary
    for electrode in electrodes:
        if f"{electrode}_eeg" not in history:
            history[f"{electrode}_eeg"] = deque(maxlen=MAX_HISTORY)
    
    try:
        if control_event and control_event.is_set():
            return {'action': 'cancel'}
            
        # Get current terminal dimensions
        width = term.width
        height = term.height
        
        # Calculate graph dimensions based on current size
        graph_width = width // 2 - 4
        graph_height = (height - 14) // 2  # Reduced from -10 to -14 for better consistency
        
        # Calculate side margin for centering
        margin_x = (width - graph_width * 2) // 3
        
        # Graph positions (2x2 grid) with better distribution
        positions = [
            (margin_x, 5, graph_width, graph_height),                         
            (margin_x * 2 + graph_width, 5, graph_width, graph_height),       
            (margin_x, 5 + graph_height + 1, graph_width, graph_height),      # Reduced from +2 to +1
            (margin_x * 2 + graph_width, 5 + graph_height + 1, graph_width, graph_height)  # Reduced from +2 to +1
        ]
            
        # Clear screen
        print(term.clear)
        
        # Get current controller state
        app_state = state_info['app_state']
        message = state_info['message']
        capture_count = state_info.get('capture_count', 0)
        countdown_seconds = state_info.get('countdown_seconds', 0)
        
        # Show header with scenario type
        view_header(term, y_start=1, scenario_type=state_info.get('scenario_type'))
        
        # Get current data from controller
        eeg_values, imp_values = data_provider()
        
        # Draw graphs for each electrode
        for i, electrode in enumerate(electrodes):
            x, y, w, h = positions[i]
            imp_value = imp_values.get(electrode, 0)
            eeg_value = eeg_values.get(electrode, 0)
            
            view_electrode_graph(
                term, x, y, w, h,
                electrode, imp_value, history,
                app_state, eeg_value
            )
        
        # Configuration for progress bars according to state
        countdown = None
        progress = None
        
        if app_state == APP_STATE_COUNTDOWN:
            countdown = (countdown_seconds, INITIAL_DELAY)
        elif app_state == APP_STATE_CAPTURE:
            progress = (capture_count, NUM_SAMPLES)
        
        # Show status bar
        view_status_bar(term, height - 7, app_state, message, countdown, progress)  # Changed from -5 to -7
        
        # Check user input
        inp = term.inkey(timeout=0.1)
        
        # If ESC is pressed, cancel operation
        if inp.code == term.KEY_ESCAPE:
            return {'action': 'cancel', 'app_state': APP_STATE_ERROR}
            
        # If we have completed or there's an error, return control
        if app_state in [APP_STATE_COMPLETE, APP_STATE_ERROR]:
            time.sleep(0.5)  # Show final message briefly
            return {'action': 'complete', 'app_state': app_state}
            
    except Exception as e:
        print(term.move_xy(2, height - 2) + term.clear_eol + f"Error in visualization: {str(e)}")
        return {'action': 'error', 'app_state': APP_STATE_ERROR, 'message': str(e)}
    
    # If there are no special events, return normal_update
    return {'action': 'normal_update'}